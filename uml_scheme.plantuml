@startuml
'note "typedef int t_sock" as N1

struct t_request_line {
std::string method
std::string path
std::string http_version
}

struct t_http_message {
t_request_line \t\t\t\t\trequest_line
std::map<std::string, std::string> \theader_fields
std::vector<char> \t\t\t\tbody
}

struct t_network_address {
in_address_t	address
in_port_t		port
}

abstract class Socket {
// Pour les listen_socket
-t_sock \t\t\t\t\t\t\tsocket
-t_network_address				netAddr
Socket(t_network_address netAddr)
+virtual bool \t\t\t\t\t\tread()
}
note right of Socket::read
always returns false
endnote

class ListenSocket {
// Pour les listen_socket
-t_sock \t\t\t\t\t\t\tsocket
-t_network_address				netAddr
ListenSocket(t_network_address netAddr)
+virtual bool \t\t\t\t\t\tread()
}

class Connexion {
-t_sock \t\t\t\t\tsocket
-t_network_address		netAddr
-t_http_message\t\t\trequest
-t_http_message\t\t\tresponse
-std::string \t\t\t\tbuffer
-Route*\t\t\t\t\troute
' -catch Error:Error413
' -catch Error:Error403
-Ressource*\t\t\t\tressource
Connexion(t_network_address netAddr, t_sock socket)
-virtual bool \t\t\t\tread_header()
-virtual bool \t\t\t\tread_body()
+virtual bool \t\t\t\tread()
+virtual void \t\t\t\twrite()
+virtual void \t\t\t\terror()
+void \t\t\t\t\tget_header()
-void \t\t\t\t\tparse_header()
}
note right of Connexion::read_header
returns true when the header is parsed
and no exception is thrown
endnote

class Server {
Server(std::string conFile)
-static std::vector<Socket>\t\tsocks
-static socket\t\t\t\t\tepollFdSock
-static std::vector<Ressource> \tressources
-static socket\t\t\t\t\tepollFdRessources
-Router \t\t\t\t\t\trouter
+void\t\t\t\t\t\t\troutine()
+static void\t\t\t\t\taddSock(Socket sock)
-static void\t\t\t\t\taddRessource(Ressource ressource)
+static \t\t\t\t\t\trmSock(Socket &sock)
}

class Router{
// typedef std::map<t_network_address, std::map<std::string, Route>> router_map
Router(Config_file &config)
-router_map 								my_map
+void 									setRoute(Connexion &conn)
-bool 									checkHeader(t_http_message &msg)
+std::vector<std::pair<in_addr_t, in_port_t>	getAddr()

}
note right of Router::set_route
Ne set route que si prerequisites are good
endnote

class Route{
 // typedef char \t\t\t\t\tt_methods
-t_methods \t\\t\t\t\t\tmethods_allowed
-size_t \t\t\t\t\t\t\tmax_body_length
-std::vector<std::string>   \t\t\tserver_names
-std::map<uint,std::string> \t\t\terrors
-std::string \t\t\t\t\t\tredirect
-std::string \t\t\t\t\t\tstatic_file
-bool \t\t\t\t\t\t\tdirectory_listing

+void \t\t\t\t\t\t\thandle(Connexion &conn)
-void \t\t\t\t\t\t\tcreate_ressource(Connexion &conn)
}

Abstract class Ressource{
// typedef int		fd
Ressource(std::string *conn_buffer)
std::string		\t\t\t\*conn_buffer
virtual bool			read()
}

class	CGI{
	' catch Error::Error503
}

class 	File{

}

class	Directory{

}

class Error{
class Error413: Public std::exception
class Error403: Public std::exception
class Error503: Public std::exception
}
note right of Error::Error413
max body length either doesn't respect
the length allowed in the config or the
route
endnote
note right of Error::Error403
Method not allowed
endnote

ListenSocket --|> Socket
Ressource --* Connexion
CGI--|> Ressource
File--|> Ressource
Directory--|> Ressource
Connexion --|> Socket
Socket --* Server
Route --* Connexion
t_request_line --* t_http_message
t_http_message --* Connexion
@enduml
