@startuml
'note "typedef int t_sock" as N1

struct t_request_line {
std::string method
std::string path
std::string http_version
}

struct t_http_message {
t_request_line \t\t\t\t\trequest_line
std::map<std::string, std::string> \theader_fields
std::vector<char> \t\t\t\tbody
}

class Socket {
// Pour les listen_socket
-t_sock \t\t\t\t\t\t\tsocket
-in_address_t\t\t\t\t\t\taddress
-in_port_t\t\t\t\t\t\tport
+virtual bool \t\t\t\t\t\tread()
+virtual void \t\t\t\t\t\twrite()
+virtual void \t\t\t\t\t\terror()
}
note right of Socket::read
always returns false
endnote

Connection --|> Socket

class Connection {
-t_http_message\t\t\trequest
-t_http_message\t\t\tresponse
-std::string \t\t\t\tbuffer
-Basic_route&\t\t\t\troute
+virtual bool \t\t\t\tread()
+virtual void \t\t\t\twrite()
+virtual void \t\t\t\terror()
+void \t\t\t\t\tget_header()
-void \t\t\t\t\tparse_header()
+void \t\t\t\t\tset_route(Basic_route route)
}
note right of Connection::read
returns true when the header is parsed
endnote


Socket --* Server
class Server {
Server(Router router, std::vector<in_port_t> listen_socket)
-std::vector<Socket>\tsocks
-socket\t\t\t\tepollfd
-Router \t\t\t\trouter
+void\t\t\t\t\troutine()
-Basic_route\t\t\tget_route_for_conn(Connection conn)
}

class Router{
// typedef std::map<std::pair<in_addr_t, in_port_t>, std::map<std::string, Basic_route>> router_map
router_map \tmy_map

}

t_request_line --* t_http_message
t_http_message --* Connection
@enduml
